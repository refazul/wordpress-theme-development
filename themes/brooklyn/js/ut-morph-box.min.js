!function(e){"use strict";function t(e){let t=e.toString();return-1===t.indexOf(".")&&(t+="."),t}class n{constructor(e,t,n={}){this.container=e,this.itemsWrapper=t,this.initialised=!1,this.camera=null,this.scene=null,this.renderer=null,n.scrollContainer=n.scrollContainer||null,n.timing=n.timing||{},n.timing.type=n.timing.type||"sameEnd",n.timing.sections=n.timing.sections||1,n.timing.latestStart=n.timing.latestStart||.5,n.timing.duration=n.timing.duration||1,n.transformation=n.transformation||{},n.transformation.type=n.transformation.type||"none",n.transformation.props=n.transformation.props||{},n.activation.type=n.activation.type||"topLeft",n.seed=n.seed||0,n.easings=n.easings||{},n.easings.toFullscreen=n.easings.toFullscreen||Power0.easeNone,n.easings.toGrid=n.easings.toGrid||Power0.easeNone,n.flipBeizerControls=n.flipBeizerControls||{},n.flipBeizerControls.c0=n.flipBeizerControls.c0||{},n.flipBeizerControls.c0.x=n.flipBeizerControls.c0.x||.5,n.flipBeizerControls.c0.y=n.flipBeizerControls.c0.y||.5,n.flipBeizerControls.c1=n.flipBeizerControls.c1||{},n.flipBeizerControls.c1.x=n.flipBeizerControls.c1.x||.5,n.flipBeizerControls.c1.y=n.flipBeizerControls.c1.y||.5,this.options=n,this.uniforms={uImage:new THREE.Uniform(null),uImageRes:new THREE.Uniform(new THREE.Vector2(1,1)),uImageLarge:new THREE.Uniform(null),uImageLargeRes:new THREE.Uniform(new THREE.Vector2(1,1)),uProgress:new THREE.Uniform(0),uMeshScale:new THREE.Uniform(new THREE.Vector2(1,1)),uPlaneCenter:new THREE.Uniform(new THREE.Vector2(0,0)),uViewSize:new THREE.Uniform(new THREE.Vector2(1,1)),uScaleToViewSize:new THREE.Uniform(new THREE.Vector2(1,1)),uClosestCorner:new THREE.Uniform(0),uMouse:new THREE.Uniform(new THREE.Vector2(0,0)),uSeed:new THREE.Uniform(n.seed),uProgressByParts:new THREE.Uniform("sections"===n.timing.type),uActivationParts:new THREE.Uniform(n.timing.sections),uSyncLatestStart:new THREE.Uniform(n.timing.latestStart),uBeizerControls:new THREE.Uniform(new THREE.Vector4(n.flipBeizerControls.c0.x,n.flipBeizerControls.c0.y,n.flipBeizerControls.c1.x,n.flipBeizerControls.c1.y))},this.textures=[],this.currentImageIndex=-1,this.isFullscreen=!1,this.isAnimating=!1,this.onResize=this.onResize=this.onResize.bind(this)}resetUniforms(){this.uniforms.uMeshScale.value=new THREE.Vector2(1,1),this.uniforms.uPlaneCenter.value=new THREE.Vector2(0,0),this.uniforms.uScaleToViewSize.value=new THREE.Vector2(1,1),this.uniforms.uClosestCorner.value=0,this.uniforms.uMouse.value=new THREE.Vector2(0,0),this.uniforms.uImage.value=null,this.uniforms.uImageRes.value=new THREE.Vector2(1,1),this.uniforms.uImageLarge.value=null,this.uniforms.uImageLargeRes.value=new THREE.Vector2(1,1);const e=this.mesh;e.scale.x=1e-5,e.scale.y=1e-5,e.position.x=0,e.position.y=0}createTextures(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n],a=new THREE.Texture(i.large.image);a.generateMipmaps=!1,a.wrapS=a.wrapT=THREE.ClampToEdgeWrapping,a.minFilter=THREE.LinearFilter,a.needsUpdate=!0,a.premultiplyAlpha=!0;const o=new THREE.Texture(i.small.image);o.generateMipmaps=!1,o.wrapS=o.wrapT=THREE.ClampToEdgeWrapping,o.minFilter=THREE.LinearFilter,o.needsUpdate=!0,o.premultiplyAlpha=!0;const r={large:{element:i.large.element,texture:a},small:{element:i.small.element,texture:o}};t.push(r)}this.textures=t,this.setCurrentTextures()}setCurrentTextures(){if(-1===this.currentImageIndex)return;const e=this.textures[this.currentImageIndex];this.uniforms.uImage.value=e.small.texture,this.uniforms.uImageRes.value.x=e.small.texture.image.naturalWidth,this.uniforms.uImageRes.value.y=e.small.texture.image.naturalHeight,this.uniforms.uImageLarge.value=e.large.texture,this.uniforms.uImageLargeRes.value.x=e.large.texture.image.naturalWidth,this.uniforms.uImageLargeRes.value.y=e.large.texture.image.naturalHeight,this.isAnimating||this.render()}init(){this.renderer=new THREE.WebGLRenderer({alpha:1,antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight),this.container.appendChild(this.renderer.domElement),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e4),this.camera.position.z=50,this.camera.lookAt=this.scene.position;const t=this.getViewSize();this.uniforms.uViewSize.value=new THREE.Vector2(t.width,t.height);var n=new THREE.PlaneBufferGeometry(1,1,128,128);const c=function(e){return e&&"[object Function]"==={}.toString.call(e)}(this.options.transformation.type)?this.options.transformation.type(this.options.transformation.props):a[this.options.transformation.type](this.options.transformation.props),u=function(e,t){return{fragment:"\n    uniform float uProgress;\n    uniform sampler2D uImage;\n    uniform vec2 uImageRes;\n    uniform sampler2D uImageLarge;\n    uniform vec2 uImageLargeRes;\n    uniform vec2 uMeshScale;\n    \n    varying vec2 vUv;\n    varying float vProgress;\n    varying vec2 scale;\n\n\n    vec2 preserveAspectRatioSlice(vec2 uv, vec2 planeSize, vec2 imageSize ){\n      \n        vec2 ratio = vec2(\n            min((planeSize.x / planeSize.y) / (imageSize.x / imageSize.y), 1.0),\n            min((planeSize.y / planeSize.x) / (imageSize.y / imageSize.x), 1.0)\n        );\n        \n        \n        vec2 sliceUvs = vec2(\n            uv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n            uv.y * ratio.y + (1.0 - ratio.y) * 0.5\n        );\n\n        return sliceUvs;\n    }\n\n    void main(){\n \n        vec2 uv = vUv;\n\n        vec2 scaledPlane = uMeshScale * scale;\n\n        \n        vec2 smallImageUV = preserveAspectRatioSlice(uv, scaledPlane, uImageRes);\n\n        vec3 color = texture2D(uImage,smallImageUV).xyz;\n\n        if(vProgress > 0.){\n          vec2 largeImageUV = preserveAspectRatioSlice(uv, scaledPlane, uImageLargeRes);\n          color = mix(color,texture2D(uImageLarge,largeImageUV).xyz, vProgress );\n        }\n\n        gl_FragColor = vec4(color,1.);\n    }\n",vertex:`\n        ${o}\n        ${r}\n        ${s}\n        ${l}\n        ${e}\n\n    float linearStep( float edge0, float edge1, float val ) {\n        \n        float x = clamp( (val  - edge0) / (edge1 - edge0),0.,1.);\n        return x;\n        \n    }\n    \n    void main(){\n\n      vec3 pos = position.xyz;\n      vec2 newUV = uv;\n\n      float activation = getActivation(uv);\n\n      // Everything ends at the same time\n      float startAt = activation * uSyncLatestStart;\n      float vertexProgress = smoothstep(startAt,1.,uProgress);\n\n      if(uProgressByParts){\n        // Vertex end by parts\n        float activationPart = 1./uActivationParts;\n        float activationPartDuration = 1./(uActivationParts+1.);\n\n        float progressStart = (activation / activationPart) * activationPartDuration;\n        float progressEnd = min(progressStart + activationPartDuration,1.);\n        vertexProgress = linearStep(progressStart,progressEnd,uProgress);\n      }\n        vec3 transformedPos = pos;\n        vec2 transformedUV = uv;\n        ${t||""}\n        pos = transformedPos;\n        newUV = transformedUV; \n\n        // Scale\n        // uScaleToViewSize\n        scale = vec2(\n          1. + uScaleToViewSize * vertexProgress\n        );\n        \n        // Since we are moving the mesh not the geometry the geometry is in the center        \n        vec2 flippedPos = vec2(\n          (- pos.x) ,\n          (- pos.y ) \n        );\n       \n        pos.xy *= scale;\n\n        // Move to center\n        // Mesh moves it into position. Shader moves it to the center\n        pos.y += -uPlaneCenter.y * vertexProgress;\n        pos.x += -uPlaneCenter.x * vertexProgress;\n\n        // Move slightly to the front\n        // pos.z += vertexProgress;        \n        pos.z += float(0);        \n        \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);\n        vProgress = vertexProgress;\n        vUv = newUV;\n        \n    }\n    \n`}}(i[this.options.activation.type],c);var m=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:u.vertex,fragmentShader:u.fragment,side:THREE.DoubleSide});this.mesh=new THREE.Mesh(n,m),this.scene.add(this.mesh),window.addEventListener("resize",this.onResize),this.options.scrollContainer&&this.options.scrollContainer.addEventListener("scroll",e=>{this.recalculateUniforms(e)});for(let t=0;t<this.itemsWrapper.length;t++){const n=this.itemsWrapper[t];e(n).closest("a").length?n.closest("a").addEventListener("click",this.createOnMouseDown(t)):e(n).siblings("a").length&&e(n).siblings("a").on("click",this.createOnMouseDown(t))}}createOnMouseDown(e){return t=>{this.toFullscreen(e,t)}}toGrid(){this.isFullscreen&&!this.isAnimating&&(this.isAnimating=!0,this.options.onToGridStart&&this.options.onToGridStart({index:this.currentImageIndex}),this.tween=TweenLite.to(this.uniforms.uProgress,this.options.timing.duration,{value:0,ease:this.options.easings.toGrid,onUpdate:()=>{this.render()},onComplete:()=>{this.isAnimating=!1,this.isFullscreen=!1,this.container.style.zIndex=0,this.resetUniforms(),this.render(),this.options.onToGridFinish&&this.options.onToGridFinish({index:-1,lastIndex:this.currentImageIndex}),this.currentImageIndex=-1}}))}recalculateUniforms(e){if(-1===this.currentImageIndex)return;const t=this.itemsWrapper[this.currentImageIndex].getBoundingClientRect(),n={x:(e.clientX-t.left)/t.width,y:1-(e.clientY-t.top)/t.height},i=2*(t.left>window.innerWidth-(t.left+t.width))+(t.top>window.innerHeight-(t.top+t.height));this.uniforms.uClosestCorner.value=i,this.uniforms.uMouse.value=new THREE.Vector2(n.x,n.y);const a=this.getViewSize(),o=t.width*a.width/window.innerWidth,r=t.height*a.height/window.innerHeight,s=t.left*a.width/window.innerWidth-a.width/2,l=t.top*a.height/window.innerHeight-a.height/2,c=this.mesh;c.scale.x=o,c.scale.y=r;let u=s+o/2,m=-l-r/2;c.position.x=u,c.position.y=m,this.uniforms.uPlaneCenter.value.x=u/o,this.uniforms.uPlaneCenter.value.y=m/r,this.uniforms.uMeshScale.value.x=o/2,this.uniforms.uMeshScale.value.y=r/2,this.uniforms.uScaleToViewSize.value.x=a.width/o-1,this.uniforms.uScaleToViewSize.value.y=a.height/r-1}toFullscreen(e,t){if(!this.isFullscreen&&!this.isAnimating){if(this.isAnimating=!0,this.currentImageIndex=e,this.recalculateUniforms(t),this.textures[e]){const t=this.textures[e];this.uniforms.uImage.value=t.small.texture,this.uniforms.uImageRes.value.x=t.small.texture.image.naturalWidth,this.uniforms.uImageRes.value.y=t.small.texture.image.naturalHeight,this.uniforms.uImageLarge.value=t.large.texture,this.uniforms.uImageLargeRes.value.x=t.large.texture.image.naturalWidth,this.uniforms.uImageLargeRes.value.y=t.large.texture.image.naturalHeight}this.container.style.zIndex=2,this.options.onToFullscreenStart&&this.options.onToFullscreenStart({index:this.currentImageIndex}),this.tween=TweenLite.to(this.uniforms.uProgress,this.options.timing.duration,{value:1,ease:this.options.easings.toFullscreen,onUpdate:()=>{this.render()},onComplete:()=>{this.isAnimating=!1,this.isFullscreen=!0,this.options.onToFullscreenFinish&&this.options.onToFullscreenFinish({index:this.currentImageIndex})}})}}getViewSize(){const e=this.camera.fov*Math.PI/180,t=Math.abs(this.camera.position.z*Math.tan(e/2)*2);return{width:t*this.camera.aspect,height:t}}render(){this.renderer.render(this.scene,this.camera)}onResize(e){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight),this.currentImageIndex>-1&&(this.recalculateUniforms(e),this.render())}}var i={corners:"\n    float getActivation(vec2 uv){\n      float top = (1.-uv.y);\n      float right = uv.x;\n      float bottom = uv.y;\n      float left = 1.- uv.x;\n\n      return top *0.333333 + (right * 0.333333 + (right * bottom)*0.666666 );\n  }\n  ",topLeft:"\n    float getActivation(vec2 uv){\n        return (+uv.x-uv.y+1.)/2.;\n    }\n  ",sides:"\n      float getActivation(vec2 uv){\n        return min(uv.x, 1.-uv.x) * 2.;\n      }\n  ",left:"\n    float getActivation(vec2 uv){\n        return uv.x;\n    }\n    ",top:"\n    float getActivation(vec2 uv){\n        return 1. - uv.y;\n    }\n    ",bottom:"\n    float getActivation(vec2 uv){\n        return uv.y;\n    }\n    ",bottomStep:"\n    float getActivation(vec2 uv){\n        \n        \n        return uv.y;\n    }\n    ",sinX:"\n      float getActivation(vec2 uv){\n        return sin(uv.x * 3.14);\n      }\n    ",center:"\n      float getActivation(vec2 uv){\n        float maxDistance = distance(vec2(0.),vec2(0.5));\n        float dist = distance(vec2(0.), uv-0.5);\n        return smoothstep(0.,maxDistance,dist);\n      }\n    ",mouse:"\n      float getActivation(vec2 uv){\n        float maxDistance = distance(uMouse, 1.-floor(uMouse+0.5));\n        float dist = smoothstep(0.,maxDistance,distance(uMouse,uv));\n        return dist;\n      }\n    ",closestCorner:"\n      float getActivation(vec2 uv){\n\n        float y = mod(uClosestCorner,2.) *2. -1.;\n        float x = (floor(uClosestCorner /2.)*2.-1.)*-1.;\n\n        float xAct = abs(min(0.,x)) + uv.x * x;\n        float yAct = abs(min(0.,y)) + uv.y * y;\n\n        return (xAct+yAct)/2.;\n      }\n    ",closestSide:"\n      float getActivation(vec2 uv){\n\n        float y = mod(uClosestCorner,2.) *2. -1.;\n        float x = (floor(uClosestCorner /2.)*2.-1.)*-1.;\n\n        float xAct = abs(min(0.,x)) + uv.x * x;\n        float yAct = abs(min(0.,y)) + uv.y * y;\n\n        return (xAct+yAct)/2.;\n      }\n    "};const a={none:()=>null,flipX:()=>"\n    \n        float beizerProgress = cubicBezier(vertexProgress,\n        uBeizerControls.x,uBeizerControls.y,\n        uBeizerControls.z,uBeizerControls.w);\n\n        float flippedX = -transformedPos.x;\n        transformedPos.x = mix (transformedPos.x, flippedX,beizerProgress );\n          \n          // Flip texture on flipped sections \n        // float activationAtX0 = getActivation(vec2(0.,transformedUV.y));\n        // float activationAtX1 = getActivation(vec2(1.,transformedUV.y));\n        //   float syncDifference = \n        //     activationAtX1 * uSyncLatestStart - activationAtX0 * uSyncLatestStart;\n          float syncDifference =  uSyncLatestStart;\n            \n            // Flip the controls because who knows why\n            // But it works exactly\n\n          // Multiply by aspect ratio to account for mesh scaling\n          float aspectRatio = (uMeshScale.x / uMeshScale.y);\n          float stepFormula = 0.5 - (syncDifference * uSyncLatestStart * uSyncLatestStart) * aspectRatio;\n\n          transformedUV.x = mix(transformedUV.x,1.-transformedUV.x,\n              step(stepFormula,beizerProgress));\n      ",simplex:e=>{t(e.seed||0);let n=t(e.amplitudeX||.5),i=t(e.amplitudeY||.5),a=t(e.frequencyX||1),o=t(e.frequencyY||.75),r=t(e.progressLimit||.5);return`\n      float simplexProgress = min(clamp((vertexProgress) / ${r},0.,1.),clamp((1.-vertexProgress) / (1.-${r}),0.,1.));\n      simplexProgress = smoothstep(0.,1.,simplexProgress);\n      float noiseX = snoise(vec2(transformedPos.x +uSeed, transformedPos.y + uSeed + simplexProgress * 1.) * ${a} ) ;\n      float noiseY = snoise(vec2(transformedPos.y +uSeed, transformedPos.x + uSeed + simplexProgress * 1.) * ${o}) ;\n      transformedPos.x += ${n} * noiseX * simplexProgress;\n      transformedPos.y += ${i} * noiseY * simplexProgress;\n  `},wavy:e=>{const n=t(e.seed||0);return`\n      float limit = 0.5;\n      float wavyProgress = min(clamp((vertexProgress) / limit,0.,1.),clamp((1.-vertexProgress) / (1.-limit),0.,1.));\n\n      float dist = length(transformedPos.xy);\n      \n      float angle = atan(transformedPos.x,transformedPos.y);\n\n      float nextDist = dist * (${t(e.amplitude||.5)} * (sin(angle * ${t(e.frequency||4)} + ${n}) /2.+0.5)+ 1.);\n\n      transformedPos.x = mix(transformedPos.x,sin(angle) * nextDist ,  wavyProgress);\n      transformedPos.y = mix(transformedPos.y,cos(angle) * nextDist,  wavyProgress);\n    `},circle:e=>"\n      float limit = 0.5;\n      float circleProgress = min(clamp((vertexProgress) / limit,0.,1.),clamp((1.-vertexProgress) / (1.-limit),0.,1.));\n\n      float maxDistance = 0.5;\n      float dist = length(transformedPos.xy);\n      \n      float nextDist = min(maxDistance,dist);\n      float overload = step(maxDistance,dist);\n      float angle = atan(transformedPos.x,transformedPos.y);\n      \n      transformedPos.x = mix(transformedPos.x,sin(angle) * nextDist ,  circleProgress );\n      transformedPos.y = mix(transformedPos.y,cos(angle) * nextDist,  circleProgress);\n      transformedPos.z += -0.5 * overload * circleProgress;\n    \n  "};var o="\n    uniform float uProgress;\n    uniform vec2 uScaleToViewSize;\n    uniform vec2 uPlaneCenter;\n    uniform vec2 uMeshScale;\n    uniform vec2 uMouse;\n    uniform vec2 uViewSize;\n    uniform float uClosestCorner;\n    uniform mat3 uvTransform;\n\n    // Option Uniforms\n    uniform float uSeed;\n    uniform vec4 uBeizerControls;\n    uniform float uSyncLatestStart;\n    uniform float uActivationParts;\n    uniform bool uProgressByParts;\n    varying vec2 vUv;\n    varying vec2 scale; \n    varying float vProgress;\n",r="\n// Helper functions:\nfloat slopeFromT (float t, float A, float B, float C){\n  float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n  return dtdx;\n}\n\nfloat xFromT (float t, float A, float B, float C, float D){\n  float x = A*(t*t*t) + B*(t*t) + C*t + D;\n  return x;\n}\n\nfloat yFromT (float t, float E, float F, float G, float H){\n  float y = E*(t*t*t) + F*(t*t) + G*t + H;\n  return y;\n}\nfloat cubicBezier (float x, float a, float b, float c, float d){\n\n  float y0a = 0.00; // initial y\n  float x0a = 0.00; // initial x \n  float y1a = b;    // 1st influence y   \n  float x1a = a;    // 1st influence x \n  float y2a = d;    // 2nd influence y\n  float x2a = c;    // 2nd influence x\n  float y3a = 1.00; // final y \n  float x3a = 1.00; // final x \n\n  float A =   x3a - 3.*x2a + 3.*x1a - x0a;\n  float B = 3.*x2a - 6.*x1a + 3.*x0a;\n  float C = 3.*x1a - 3.*x0a;   \n  float D =   x0a;\n\n  float E =   y3a - 3.*y2a + 3.*y1a - y0a;    \n  float F = 3.*y2a - 6.*y1a + 3.*y0a;             \n  float G = 3.*y1a - 3.*y0a;             \n  float H =   y0a;\n\n  // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n  // Assume for the first guess that t = x.\n  float currentt = x;\n  const int nRefinementIterations = 5;\n  for (int i=0; i < nRefinementIterations; i++){\n    float currentx = xFromT (currentt, A,B,C,D); \n    float currentslope = slopeFromT (currentt, A,B,C);\n    currentt -= (currentx - x)*(currentslope);\n    currentt = clamp(currentt, 0.,1.);\n  } \n\n  float y = yFromT (currentt,  E,F,G,H);\n  return y;\n}\n",s="\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n",l="\nfloat quadraticBezier (float x, float a, float b){\n  // adapted from BEZMATH.PS (1993)\n  // by Don Lancaster, SYNERGETICS Inc. \n  // http://www.tinaja.com/text/bezmath.html\n\n  float epsilon = 0.00001;\n  a = max(0., min(1., a)); \n  b = max(0., min(1., b)); \n  if (a == 0.5){\n    a += epsilon;\n  }\n  \n  // solve t from x (an inverse operation)\n  float om2a = 1. - 2.*a;\n  float t = (sqrt(a*a + om2a*x) - a)/om2a;\n  float y = (1.-2.*b)*(t*t) + (2.*b)*t;\n  return y;\n}\n";let c;const u=site_settings.lg_transition/1e3;let m=[],p=[];window.UT_Morph_Box_APP={init:function(e){m=[],p=[],this.reset_morph_app()},checkURL:function(e){return null!=e.match(/\.(jpeg|jpg|gif|png)$/)},reset_morph_app:function(){e("#ut-morph-box-app > canvas").remove(),e("#ut-morph-box-full").children().remove(),e("a[data-exthumbimage].ut-morphbox-ready").removeClass("ut-morphbox-ready"),this.create_morph_app()},create_morph_gallery:function(e){},create_morph_app:function(){let t=[];e("a[data-exthumbimage]").not(".ut-morphbox-ready").each(function(){let n=e(this);if(!UT_Morph_Box_APP.checkURL(n.attr("href")))return n.ut_require_js({plugin:"lightGallery",source:"lightGallery",callback:function(e){e.lightGallery({selector:"this",iframeMaxWidth:"80%",download:site_settings.lg_download,hash:!1,mode:site_settings.lg_mode})}}),!0;n.addClass("ut-morphbox-ready");let i=e("<div></div>");i.attr("class","ut-morph-box-item"),i.appendTo("#ut-morph-box-full");let a=new Image;a.src=n.attr("href"),a.classList.add("ut-morph-box-full-image");let o="";if(n.hasClass("ut-slider-maximize"))o=n.next("img").get(0);else if(n.find("img").length)o=n.find("img").get(0);else{if(void 0===n.parent().attr("data-background-image"))return;(o=new Image).src=n.parent().attr("data-background-image"),o.classList.add("ut-morph-box-small-image"),n.append(o)}let r={small:{element:o,image:o},large:{element:a,image:a}};i.append(a),t.push(r),m.push(r.small.element),p.push(i);let s=!1,l=!1,c=e('<div class="ut-morphbox-price"></div>'),u=e("<h3></h3>"),f=e("<p></p>"),d=(e("<a></a>"),e('<div data-custom-cursor="default" class="ut-morph-box-item-wrap"></div>'));n.data("caption-skin")&&d.attr("data-caption-skin",n.data("caption-skin")),n.data("price")&&""!==n.data("price")&&(c.html(n.data("price")),d.append(c),i.append(d)),"on"===n.data("force-caption")&&(""!==(l=n.data("title"))&&(u.text(n.data("title")),d.append(u),i.append(d)),""!==(s=n.data("caption"))&&(f.html(n.data("caption")),d.append(f),i.append(d)),""===l&&""===s&&d.addClass("ut-new-hide")),!l&&n.data("title")&&""!==n.data("title")&&(u.text(n.data("title")),d.append(u),i.append(d),l=n.data("title")),!s&&n.data("caption")&&""!==n.data("caption")&&n.data("caption")!==l&&(f.html(n.data("caption")),d.append(f),i.append(d),s=!0),n.data("caption-button")&&""!==n.data("caption-button")&&(d.append(e(".bklyn-btn-holder",n.data("caption-button")).clone()),i.append(d)),!s&&n.data("sub-html")&&""!==n.data("sub-html")&&e(n.data("sub-html")).text()!==l&&(f.html(e(n.data("sub-html")).text()),d.append(f),i.append(d),s=!0),s||void 0===e(r.small.element).attr("alt")||""===e(r.small.element).attr("alt")||e(r.small.element).attr("alt")!==l&&(f.html(e(r.small.element).attr("alt")),d.append(f),i.append(d),s=!0),!s&&n.parent(".gallery-icon").length&&n.parent(".gallery-icon").next(".wp-caption-text").length&&(f.html(n.parent(".gallery-icon").next(".wp-caption-text").text()),d.append(f),i.append(d),s=!0),s||!n.find("h3").length||n.find("h3").hasClass("ut-image-gallery-empty-title")||n.find("h3").length&&n.find("h3").text()!==l&&(f.html(n.find("h3").text()),d.append(f),i.append(d));let h=e('<svg class="ut-morph-box-close"><use transform="translate(11, 11) scale(0.8)" xlink:href="#ut-morph-box-close-icon" /></svg>');i.append(h),n.data("caption-color")&&""!==n.data("caption-color")&&(f.css({color:n.data("caption-color")}),u.css({color:n.data("caption-color")}),h.css({fill:n.data("caption-color")})),n.data("caption-background")&&""!==n.data("caption-background")&&(d.css({background:n.data("caption-background")}),h.css({background:n.data("caption-background")})),n.on("click",function(t){if(t.preventDefault(),UT_Morph_Box_Transition_Effect.isAnimating)return!1;n.data("cursor-skin")&&""!==n.data("cursor-skin")&&(e("#ut-morph-box-app").attr("data-cursor-skin",n.data("cursor-skin")),e("#ut-morph-box-full").attr("data-cursor-skin",n.data("cursor-skin"))),n.children(":first").data("cursor-skin")&&""!==n.children(":first").data("cursor-skin")&&(e("#ut-morph-box-app").attr("data-cursor-skin",n.children(":first").data("cursor-skin")),e("#ut-morph-box-full").attr("data-cursor-skin",n.children(":first").data("cursor-skin"))),n.addClass("ut-morph-active")})}),e("#ut-morph-box-full").imagesLoaded(function(){window.UT_Morph_Box_Transition_Effect=function(t){return new n(e("#ut-morph-box-app").get(0),m,Object.assign({scrollContainer:window,onToFullscreenStart:({index:e})=>{},onToFullscreenFinish:({index:e})=>{},onToGridStart:({index:e})=>{},onToGridFinish:({index:e,lastIndex:t})=>{}},t))}(f),UT_Morph_Box_Transition_Effect.init(),UT_Morph_Box_Transition_Effect.createTextures(t)})}};const f={onToFullscreenStart:({index:t})=>{c=t,e("#ut-morph-box-app").addClass("active"),UT_Morph_Box_Transition_Effect.uniforms.uSeed.value=10*t,d()},onToGridStart:({index:t})=>{e("#ut-morph-box-app").removeClass("active"),e(".ut-morph-active").addClass("ut-morph-back-to-grid")},onToGridFinish:({index:t})=>{e(".ut-morph-box-item-active").removeClass("ut-morph-box-item-active");let n=e(".ut-morph-active").find("[data-image-caption]");n.length?(UT_Morph_Box_Transition_Effect.isAnimating=!0,TweenLite.to(n.get(0),.2,{ease:Quad.easeOut,startAt:{opacity:"0"},opacity:1,onComplete:()=>{n.removeAttr("style"),e(".ut-morph-active").removeClass("ut-morph-active"),UT_Morph_Box_Transition_Effect.isAnimating=!1}})):e(".ut-morph-active").removeClass("ut-morph-active")}};"wobble"==site_settings.lg_effect&&(f.activation={type:"center"},f.seed=800,f.timing={duration:u},f.transformation={type:"simplex",props:{seed:"8000",frequencyX:.2,frequencyY:.2,amplitudeX:.3,amplitudeY:.3}},f.easings={toFullscreen:Power1.easeOut,toGrid:Power1.easeInOut}),"laser"==site_settings.lg_effect&&(f.activation={type:"top"},f.timing={type:"sections",sections:10,duration:u},f.easings={toFullscreen:Quint.easeInOut,toGrid:Quint.easeInOut});const d=function(){UT_Morph_Box_Transition_Effect.isFullscreen?(null!==p[c].get(0).querySelector(".ut-morph-box-item-wrap")&&TweenLite.to(p[c].get(0).querySelector(".ut-morph-box-item-wrap"),.2,{ease:Quad.easeOut,opacity:0,y:"100%"}),TweenLite.to(p[c].get(0).querySelector(".ut-morph-box-close"),.2,{ease:Quad.easeOut,opacity:0,scale:"0"}),UT_Morph_Box_Transition_Effect.toGrid(),e("#ut-morph-box-app").trigger("onAfterClose.utmorph")):(p[c].addClass("ut-morph-box-item-active"),null!==p[c].get(0).querySelector(".ut-morph-box-item-wrap")&&TweenLite.to(p[c].get(0).querySelector(".ut-morph-box-item-wrap"),1,{ease:Expo.easeOut,startAt:{y:"100%"},opacity:1,y:"0%",delay:.6*u}),TweenLite.to(p[c].get(0).querySelector(".ut-morph-box-close"),1,{ease:Expo.easeOut,startAt:{scale:"0"},opacity:1,scale:"1",delay:.6*u}),e("#ut-morph-box-app").trigger("onAfterOpen.utmorph"))};e(document).on("click",".ut-morph-box-close, #ut-morph-box-app.active",function(){UT_Morph_Box_Transition_Effect.isAnimating||d()}),document.addEventListener("keyup",function(e){if(27===e.keyCode){if(UT_Morph_Box_Transition_Effect.isAnimating||!UT_Morph_Box_Transition_Effect.isFullscreen)return;d()}})}(jQuery);